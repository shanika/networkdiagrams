<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='draw2d-Canvas'>/**
</span> * @class draw2d.Canvas
 * Interactive paint area of the draw2d library.
 * &lt;br&gt;
 * &lt;strong&gt;Usage&lt;/strong&gt;
 *      &lt;script type=&quot;text/javascript&quot;&gt;
 *      
 *      $(window).load(function () {
 *          
 *          var canvas = new draw2d.Canvas(&quot;gfx_holder&quot;);
 *      
 *          var figure1 = new draw2d.shape.basic.Oval();
 *          var figure2 = new draw2d.shape.basic.Rectangle();
 *          canvas.addFigure(figure1,100,100);
 *          canvas.addFigure(figure2,120,150);
 *      });
 *      &lt;/script&gt;
 *      
 * @inheritable
 * @author Andreas Herz
 */
draw2d.Canvas = Class.extend(
{
    NAME : &quot;draw2d.Canvas&quot;,

<span id='draw2d-Canvas-method-constructor'>    /**
</span>     * @constructor
     * Create a new canvas with the given HTML DOM references.
     * 
     * @param {String} canvasId the id of the DOM element to use a parent container
     */
    init : function(canvasId, width, height)
    {
        // Hook the canvas calculation for IE8
        //
        if (navigator.appName == 'Microsoft Internet Explorer')
        {
          var ua = navigator.userAgent;
          var re  = new RegExp(&quot;MSIE ([0-9]{1,}[\.0-9]{0,})&quot;);
          if (re.exec(ua) != null){
            rv = parseInt( RegExp.$1 );
            if(rv===8){
                this.fromDocumentToCanvasCoordinate = this._fromDocumentToCanvasCoordinate_IE8_HACK;
            }
          }
        }

        this.setScrollArea(document.body);
        this.canvasId = canvasId;
        this.html = $(&quot;#&quot;+canvasId);
        this.html.css({&quot;cursor&quot;:&quot;default&quot;});
        if(typeof width!==&quot;undefined&quot;){
            this.initialWidth = width;
            this.initialHeight = height;
        }
        else{
            this.initialWidth = this.getWidth();
            this.initialHeight = this.getHeight();
        }
        
        // avoid the &quot;highlighting&quot; in iPad, iPhone if the user tab/touch on the canvas.
        // .... I don't like this.
        this.html.css({&quot;-webkit-tap-highlight-color&quot;: &quot;rgba(0,0,0,0)&quot;});
        
        // Drag&amp;Drop Handling from foreign DIV into the Canvas
        // Only available in combination with jQuery-UI
        //
        // Create the droppable area for the css class &quot;draw2d_droppable&quot;
        // This can be done by a palette of toolbar or something else.
        // For more information see : http://jqueryui.com/demos/droppable/
        //
        if(typeof this.html.droppable !==&quot;undefined&quot;){
            this.html.droppable({
                accept: '.draw2d_droppable',
                over: $.proxy(function(event, ui) {
                    this.onDragEnter(ui.draggable);
                },this),
                out: $.proxy(function(event, ui) {
                    this.onDragLeave(ui.draggable);
                },this),
                drop:$.proxy(function(event, ui){
                    event = this._getEvent(event);
                    var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    this.onDrop(ui.draggable, pos.getX(), pos.getY());
                },this)
            });
        
            // Create the jQuery-Draggable for the palette -&gt; canvas drag&amp;drop interaction
            //
            $(&quot;.draw2d_droppable&quot;).draggable({
                appendTo:&quot;body&quot;,
                stack:&quot;body&quot;,
                zIndex: 27000,
                helper:&quot;clone&quot;,
                drag: $.proxy(function(event, ui){
                    event = this._getEvent(event);
                    var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                    this.onDrag(ui.draggable, pos.getX(), pos.getY());
                },this),
                stop: function(e, ui){
                    this.isInExternalDragOperation=false;
                },
                start: function(e, ui){
                    this.isInExternalDragOperation=true;
                    $(ui.helper).addClass(&quot;shadow&quot;);
                }
           });
        }

        // painting stuff
        //
        if(typeof height!== &quot;undefined&quot;){
            this.paper = Raphael(canvasId,width, height);
        }
        else{
            this.paper = Raphael(canvasId, this.getWidth(), this.getHeight());
        }
        this.paper.canvas.style.position=&quot;absolute&quot;;
        
        // Status handling
        //
        this.zoomFactor = 1.0; // range [0.001..10]
        this.selection  = new draw2d.Selection();
        this.currentDropTarget = null;
        this.isInExternalDragOperation=false;
        this.currentHoverFigure = null;
        
        this.editPolicy = new draw2d.util.ArrayList();

        // internal document with all figures, ports, ....
        //
        this.figures     = new draw2d.util.ArrayList();
        this.lines       = new draw2d.util.ArrayList(); // crap - why are connections not just figures. Design by accident
        this.commonPorts = new draw2d.util.ArrayList();
        this.dropTargets = new draw2d.util.ArrayList();
        
        // all visible resize handles which can be drag&amp;drop around. Selection handles like AntRectangleSelectionFeedback
        // are not part of this collection
        this.resizeHandles = new draw2d.util.ArrayList();
        
        // listener for selection handling
        // called if any selection events happens in the canvas
        //
        this.selectionListeners = new draw2d.util.ArrayList();

        // The CommandStack for undo/redo operations
        // 
        this.commandStack = new draw2d.command.CommandStack();
       
        // INTERSECTION/CROSSING handling for connections and lines
        //
        this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
        this.lineIntersections = new draw2d.util.ArrayList();
       
        this.installEditPolicy( new draw2d.policy.canvas.BoundingboxSelectionPolicy());
//        this.installEditPolicy( new draw2d.policy.canvas.FadeoutDecorationPolicy());

        // Calculate all intersection between the different lines
        //
        this.commandStack.addEventListener($.proxy(function(event){
            if(event.isPostChangeEvent()===true){
                this.calculateConnectionIntersection();
                this.linesToRepaintAfterDragDrop.each(function(i,line){
                    line.svgPathString=null;
                    line.repaint();
                });
                this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
            }
        },this));
        
        // DragDrop status handling
        //
        this.mouseDown  = false;
        this.mouseDownX = 0;
        this.mouseDownY = 0;
        this.mouseDragDiffX =0;
        this.mouseDragDiffY =0;

        this.html.bind(&quot;mouseup touchend&quot;, $.proxy(function(event)
        {
            if (this.mouseDown === false){
                return;
            }

            event = this._getEvent(event);
            this.calculateConnectionIntersection();

            this.mouseDown = false;
            var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            this.editPolicy.each($.proxy(function(i,policy){
                policy.onMouseUp(this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
            },this));
            
            this.mouseDragDiffX = 0;
            this.mouseDragDiffY = 0;
        }, this));

        this.html.bind(&quot;mousemove touchmove&quot;, $.proxy(function(event)
        {
            event = this._getEvent(event);
            if (this.mouseDown === false){
               var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
               // mouseEnter/mouseLeave events for Figures. Don't use the Raphael or DOM native functions.
               // Raphael didn't work for Rectangle with transparent fill (events only fired for the border line)
               // DOM didn't work well for lines. No eclipse area - you must hit the line exact to retrieve the event.
               // In this case I implement my own stuff...again and again.
               //
               // don't break the main event loop if one element fires an error during enter/leave event.
               try{
	               var hover = this.getBestFigure(pos.x,pos.y);
	               if(hover !== this.currentHoverFigure &amp;&amp; this.currentHoverFigure!==null){
	            	   this.currentHoverFigure.onMouseLeave();
	               }
	               if(hover !== this.currentHoverFigure &amp;&amp; hover!==null){
	            	   hover.onMouseEnter();
	               }
	               this.currentHoverFigure = hover;
               }
               catch(exc){
            	   // just write it to the console
            	   console.log(exc);
               }

               this.editPolicy.each($.proxy(function(i,policy){
                   policy.onMouseMove(this, pos.x, pos.y, event.shiftKey, event.ctrlKey);
               },this));
            }
            else{
               var diffXAbs = (event.clientX - this.mouseDownX)*this.zoomFactor;
               var diffYAbs = (event.clientY - this.mouseDownY)*this.zoomFactor;
               this.editPolicy.each($.proxy(function(i,policy){
                   policy.onMouseDrag(this,diffXAbs, diffYAbs, diffXAbs-this.mouseDragDiffX, diffYAbs-this.mouseDragDiffY);
               },this));
               this.mouseDragDiffX = diffXAbs;
               this.mouseDragDiffY = diffYAbs;
           }
        }, this));
        
        this.html.bind(&quot;mousedown touchstart&quot;, $.proxy(function(event)
        {
            var pos = null;
            switch (event.which) {
            case 1: //touch pressed
            case 0: //Left mouse button pressed
                event.preventDefault();
                event = this._getEvent(event);
                this.mouseDownX = event.clientX;
                this.mouseDownY = event.clientY;
                this.mouseDragDiffX = 0;
                this.mouseDragDiffY = 0;
                pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                this.mouseDown = true;
                this.editPolicy.each($.proxy(function(i,policy){
                    policy.onMouseDown(this,pos.x,pos.y, event.shiftKey, event.ctrlKey);
                },this));
                break;
            case 3: //Right mouse button pressed             
                event.preventDefault();
                event = this._getEvent(event);
                pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                this.onRightMouseDown(pos.x, pos.y, event.shiftKey, event.ctrlKey);
                break;
            case 2:
                //Middle mouse button pressed
                break;
             default:
                //You have a strange mouse
            }
        }, this));
        
        
        // Catch the dblclick and route them to the Canvas hook.
        //
        $(document).bind(&quot;dblclick&quot;,$.proxy(function(event)
        {
            event = this._getEvent(event);

            this.mouseDownX = event.clientX;
            this.mouseDownY = event.clientY;
            var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
            this.onDoubleClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
        },this));

        
        // Catch the keyDown and CTRL-key and route them to the Canvas hook.
        //
        $(document).bind(&quot;click&quot;,$.proxy(function(event)
        {
            event = this._getEvent(event);

            // fire only the click event if we didn't move the mouse (drag&amp;drop)
            //
            if(this.mouseDownX === event.clientX ||  this.mouseDownY === event.clientY){
                var pos = this.fromDocumentToCanvasCoordinate(event.clientX, event.clientY);
                this.onClick(pos.x, pos.y, event.shiftKey, event.ctrlKey);
            }
        },this));

        // Catch the keyDown and CTRL-key and route them to the Canvas hook.
        //
        $(document).bind(&quot;keydown&quot;,$.proxy(function(event)
        {
          // don't initiate the delete command if the event comes from an INPUT field. In this case the user want delete
          // a character in the input field and not the related shape
          if(!$(event.target).is(&quot;input&quot;)){
             var ctrl = event.ctrlKey;
             this.onKeyDown(event.keyCode, ctrl);
           }
        },this));

    },

<span id='draw2d-Canvas-method-hideDecoration'>    /**
</span>     * @method
     * Callback for any kind of image export tools to trigger the canvas to hide all unwanted
     * decorations. The method is called e.g. from the draw2d.io.png.Writer
     * 
     * @since 4.0.0
     * @template
     */
    hideDecoration: function(){
    	
    },

<span id='draw2d-Canvas-method-showDecoration'>    /**
</span>     * @method
     * callback method for any image export writer to reactivate the decoration
     * of the canvas. e.g. grids, rulers,...
     * 
     * 
     * @since 4.0.0
     * @template
     */
    showDecoration: function(){
    	
    },

<span id='draw2d-Canvas-method-calculateConnectionIntersection'>    /**
</span>     * @method
     * Calculate all connection intersection of the canvas.
     * Required for &quot;bridging&quot; or &quot;crossing decoration&quot;
     * 
     * @private
     */
    calculateConnectionIntersection: function(){

        this.lineIntersections = new draw2d.util.ArrayList();
        var lines = this.getLines().clone();
        while(lines.getSize()&gt;0){
            var l1 = lines.removeElementAt(0);
            lines.each($.proxy(function(ii,l2){
                var partInter =l1.intersection(l2);
                if(partInter.getSize()&gt;0){
                   this.lineIntersections.add({line:l1, other:l2, intersection:partInter});
                   this.lineIntersections.add({line:l2, other:l1, intersection:partInter});
                }
            },this));
        }
    },

<span id='draw2d-Canvas-method-clear'>    /**
</span>     * @method
     * reset the canvas and delete all model elements.&lt;br&gt;
     * You can now reload another model to the canvas with a {@link draw2d.io.Reader}
     * 
     * @since 1.1.0
     */
    clear : function(){
        
        this.lines.clone().each($.proxy(function(i,e){
            this.removeFigure(e);
        },this));
        
         this.figures.clone().each($.proxy(function(i,e){
            this.removeFigure(e);
        },this));
        
        this.zoomFactor =1.0;
        this.selection.clear();
        this.currentDropTarget = null;
        this.isInExternalDragOperation=false;

        // internal document with all figures, ports, ....
        //
        this.figures = new draw2d.util.ArrayList();
        this.lines = new draw2d.util.ArrayList();
        this.commonPorts = new draw2d.util.ArrayList();
        this.dropTargets = new draw2d.util.ArrayList();
       
        this.commandStack.markSaveLocation();
        
        // INTERSECTION/CROSSING handling for connections and lines
        //
        this.linesToRepaintAfterDragDrop =  new draw2d.util.ArrayList();
        this.lineIntersections = new draw2d.util.ArrayList();
        
        // Inform all listener that the selection has been cleanup. Normally this will be done
        // by the edit policies of the canvas..but exceptional this is done in the clear method as well -
        // Design flaw.
        this.selectionListeners.each(function(i,w){
            w.onSelectionChanged(null);
        });
    },
    
<span id='draw2d-Canvas-method-installEditPolicy'>    /**
</span>     * @method
     * 
     * Install a new selection and edit policy into the canvas
     * 
     * @since 2.2.0
     * @param {draw2d.policy.EditPolicy} policy
     */
    installEditPolicy: function(policy){
        // a canvas can handle only one selection policy
        //
        if(policy instanceof draw2d.policy.canvas.SelectionPolicy){
            // reset old selection before install new selection strategy
            this.getSelection().getAll().each(function(i,figure){
                figure.unselect();
            });
            
            // remove existing selection policy
            this.editPolicy.grep($.proxy(function(p){
                var stay = !(p instanceof draw2d.policy.canvas.SelectionPolicy); 
                if(stay===false){
                    p.onUninstall(this);
                }
                return stay;
            },this));
        }
        // only one SnapToXYZ edit policy at once
        else if (policy instanceof draw2d.policy.canvas.SnapToEditPolicy){
            // remove existing snapTo policy
            this.editPolicy.grep($.proxy(function(p){
                var stay = !(p instanceof draw2d.policy.canvas.SnapToEditPolicy); 
                if(stay===false){
                    p.onUninstall(this);
                }
                return stay;
            },this));
        }
        
        policy.onInstall(this);
        this.editPolicy.add(policy);    
    },
    
<span id='draw2d-Canvas-method-uninstallEditPolicy'>    /**
</span>     * @method
     * 
     * UnInstall the selection and edit policy from the canvas.
     * 
     * @since 2.2.0
     * @param {draw2d.policy.EditPolicy} policy
     */
    uninstallEditPolicy: function(policy){
        if(!(policy instanceof draw2d.policy.EditPolicy)){
            return; // silently
        }
        
        this.editPolicy.grep($.proxy(function(p){
            if(p === policy || (p.NAME === policy.NAME)){
                p.onUninstall(this);
                return false;
            }
            return true;
        },this));
    },
    
<span id='draw2d-Canvas-method-setZoom'>    /**
</span>     * @method
     * Set the new zoom factor for the canvas. The value must be between [0.01..10]
     * 
     * @param {Number} zoomFactor new zoom factor.
     * @param {boolean} [animated] set it to true for smooth zoom in/out
     */
    setZoom : function(zoomFactor, animated)
    {
        var _zoom = $.proxy(function(z){
            this.zoomFactor = Math.min(Math.max(0.01,z),10);
            
            var viewBoxWidth  = (this.initialWidth*(this.zoomFactor))|0;
            var viewBoxHeight = (this.initialHeight*(this.zoomFactor))|0;
            
            this.paper.setViewBox(0, 0, viewBoxWidth, viewBoxHeight);
            
            // BUG: raphael didn't handle setViewBox AND setSize correct
//            var paintArea =this.html.children(&quot;:first&quot;);
//            this.paper.setSize(this.html.width(), this.html.height());
            
            // didn't work too....   :-(
//            paintArea.width(this.initialWidth * this.zoomFactor);
//            paintArea.height(this.initialHeight * this.zoomFactor);
        },this);
        
       if(animated){
           var myTweenable = new Tweenable();
           myTweenable.tween({
             from:     { 'x': this.zoomFactor  },
             to:       { 'x': zoomFactor },
             duration: 300,
             easing : &quot;easeOutSine&quot;,
             step: function (params) {
               _zoom(params.x);
             }
           });
       }
       else{
           _zoom(zoomFactor);
       }
    },

<span id='draw2d-Canvas-method-getZoom'>    /**
</span>     * @method
     * Return the current zoom factor of the canvas.
     * 
     * @returns {Number}
     */
    getZoom: function(){
        return this.zoomFactor;
    },
    
<span id='draw2d-Canvas-method-getDimension'>    /**
</span>     * @method
     * Return the dimension of the drawing area
     * 
     * @since 4.4.0
     * @returns {draw2d.geo.Rectangle}
     */
    getDimension : function(){
        return new draw2d.geo.Rectangle(0,0,this.initialWidth, this.initialHeight);
    },
    
<span id='draw2d-Canvas-method-setDimension'>    /**
</span>     * @method
     * Tells the canvas to resize. If you do not specific any parameters 
     * the canvas will attempt to determine the height and width by the enclosing bounding box 
     * of all elements and set the dimension accordingly. If you would like to set the dimension 
     * explicitly pass in an draw2d.geo.Rectangle or an object with &lt;b&gt;height&lt;/b&gt; and &lt;b&gt;width&lt;/b&gt; properties.
     * 
     * @since 4.4.0
     * @param {draw2d.geo.Rectangle} [dim] the dimension to set or null for autodetect
     */
    setDimension : function(dim){
        if (typeof dim === &quot;undefined&quot;){
            var widths  = this.getFigures().clone().map(function(f){ return f.getAbsoluteX()+f.getWidth();});
            var heights = this.getFigures().clone().map(function(f){ return f.getAbsoluteY()+f.getHeight();});
            this.initialHeight = Math.max.apply(Math,heights.asArray());
            this.initialWidth  = Math.max.apply(Math,widths.asArray());
        }
        else if(dim instanceof draw2d.geo.Rectangle){
            this.initialWidth  = dim.w;
            this.initialHeight = dim.h;
        }
        else if(typeof dim.width ===&quot;number&quot; &amp;&amp; typeof dim.height ===&quot;number&quot;){
            this.initialWidth  = dim.width;
            this.initialHeight = dim.height;
        }
        this.html.css({&quot;width&quot;:this.initialWidth+&quot;px&quot;, &quot;height&quot;:this.initialHeight+&quot;px&quot;});
        this.paper.setSize(this.initialWidth, this.initialHeight);
        this.setZoom(this.zoomFactor, false);
    },
    
    
    
<span id='draw2d-Canvas-method-fromDocumentToCanvasCoordinate'>    /**
</span>     * @method
     * Transforms a document coordinate to canvas coordinate.
     * 
     * @param {Number} x the x coordinate relative to the window 
     * @param {Number} y the y coordinate relative to the window
     * 
     * @returns {draw2d.geo.Point} The coordinate in relation to the canvas [0,0] position
     */
    fromDocumentToCanvasCoordinate : function(x, y) {
        return new draw2d.geo.Point(
                (x - this.getAbsoluteX() + this.getScrollLeft())*this.zoomFactor,
                (y - this.getAbsoluteY() + this.getScrollTop())*this.zoomFactor);
    },
  
    _fromDocumentToCanvasCoordinate_IE8_HACK : function(x, y) {
   //     alert(&quot;dd&quot;);
            return new draw2d.geo.Point(
                    (x - this.getAbsoluteX())*this.zoomFactor,
                    (y - this.getAbsoluteY())*this.zoomFactor);
    },

<span id='draw2d-Canvas-method-fromCanvasToDocumentCoordinate'>    /**
</span>     * @method
     * Transforms a canvas coordinate to document coordinate.
     * 
     * @param {Number} x the x coordinate in the canvas 
     * @param {Number} y the y coordinate in the canvas
     * 
     * @returns {draw2d.geo.Point} the coordinate in relation to the document [0,0] position
     */
    fromCanvasToDocumentCoordinate : function(x,y) {
        return new draw2d.geo.Point(
                ((x*(1/this.zoomFactor)) + this.getAbsoluteX() - this.getScrollLeft()),
                ((y*(1/this.zoomFactor)) + this.getAbsoluteY() - this.getScrollTop()));
    },
    
<span id='draw2d-Canvas-method-getHtmlContainer'>    /**
</span>     * @method
     * The DOM host of the canvas
     * 
     * @returns {HTMLElement}
     */
    getHtmlContainer: function(){
       return this.html; 
    },
    
    
<span id='draw2d-Canvas-method-_getEvent'>    /**
</span>     * @method
     * Return a common event object independed if we run on an iPad or desktop.
     * 
     * @param event
     * @return
     * @private
     */
    _getEvent:function(event){
      // check for iPad, Android touch events
      //
      if(typeof event.originalEvent !== &quot;undefined&quot;){  
          if(event.originalEvent.touches &amp;&amp; event.originalEvent.touches.length) {
               return event.originalEvent.touches[0];
          } else if(event.originalEvent.changedTouches &amp;&amp; event.originalEvent.changedTouches.length) {
               return event.originalEvent.changedTouches[0];
          }
      }
      return event;
    },

<span id='draw2d-Canvas-method-setScrollArea'>    /**
</span>     * @method
     * 
     * Set the area which are scrolling the canvas. This can be a jquery selector or 
     * a jQuery node.
     * 
     * @param {String/HTMLElement} elementSelector
     **/
    setScrollArea:function(elementSelector)
    {
       this.scrollArea= $(elementSelector);
    },

<span id='draw2d-Canvas-method-getScrollArea'>    /**
</span>     * @method
     * 
     * return the scrolling area of the canvas. This is jQuery object
     * 
     * @return {HTMLElement} 
     **/
    getScrollArea:function()
    {
       return this.scrollArea;
    },

<span id='draw2d-Canvas-method-getScrollLeft'>    /**
</span>     * @method
     * The left scroll position.
     * 
     * @return {Number} the left scroll offset of the canvas
     **/
    getScrollLeft:function()
    {
      return this.scrollArea.scrollLeft();
    },

<span id='draw2d-Canvas-method-getScrollTop'>    /**
</span>     * @method
     * The top scroll position
     * 
     * @return {Number} the top scroll offset of the cnavas.
     **/
    getScrollTop:function()
    {
      return this.scrollArea.scrollTop();
    },

<span id='draw2d-Canvas-method-getAbsoluteX'>    /**
</span>     * @method
     * The absolute document x offset.
     *
     * @return {Number}
     **/
    getAbsoluteX:function()
    {
        return this.html.offset().left;
    },

<span id='draw2d-Canvas-method-getAbsoluteY'>    /**
</span>     * @method
     * The absolute document y offset.
     * 
     * @return {Number} 
     **/
    getAbsoluteY:function()
    {
      return this.html.offset().top;
    },


<span id='draw2d-Canvas-method-getWidth'>    /**
</span>     * @method
     * Return the width of the canvas
     * 
     * @return {Number}
     **/
    getWidth : function(){
        return this.html.width();
    },


<span id='draw2d-Canvas-method-getHeight'>    /**
</span>     * @method
     * Return the height of the canvas.
     * 
     * @return {Number}
     **/
    getHeight:function() {
      return this.html.height();
    },
 

<span id='draw2d-Canvas-method-addFigure'>    /**
</span>     * @method
     * Add a figure at the given x/y coordinate.
     *
     * @param {draw2d.Figure} figure The figure to add.
     * @param {Number} [x] The x position.
     * @param {Number} [y] The y position.
     **/
    addFigure:function( figure , x,  y)
    {
        if(figure.getCanvas()===this){
            return;
        }
        
      figure.setCanvas(this);

      // important inital 
      figure.getShapeElement();


      if(figure instanceof draw2d.shape.basic.Line){
        this.lines.add(figure);
        this.linesToRepaintAfterDragDrop = this.lines;
      }
      else{
        this.figures.add(figure);

        if(typeof y !== &quot;undefined&quot;){
            figure.setPosition(x,y);
        }
      }
      
      // init a repaint of the figure. This enforce that all properties
      // ( color, dim, stroke,...) will be set.
      figure.repaint();
      figure.fireMoveEvent();
    },

<span id='draw2d-Canvas-method-removeFigure'>    /**
</span>     * @method
     * Remove a figure from the Canvas.
     *
     * @param {draw2d.Figure} figure The figure to remove
     **/
    removeFigure:function(figure){
        // remove the figure froma selection handler as well and cleanup the 
        // selection feedback 
        this.editPolicy.each($.proxy(function(i,policy){
            if(typeof policy.unselect===&quot;function&quot;){
                policy.unselect(this,figure);
            }
        },this));
        

        if(figure instanceof draw2d.shape.basic.Line){
           this.lines.remove(figure);
         }
        else {
           this.figures.remove(figure);
        }
        figure.setCanvas(null);

        if(figure instanceof draw2d.Connection){
           figure.disconnect();
        }

    },
    
<span id='draw2d-Canvas-method-getLines'>    /**
</span>     * @method
     * Returns all lines/connections in this workflow/canvas.&lt;br&gt;
     *
     * @protected
     * @return {draw2d.util.ArrayList}
     **/
    getLines:function()
    {
      return this.lines;
    },

<span id='draw2d-Canvas-method-getFigures'>    /**
</span>     * @method
     * Returns the internal figures container.&lt;br&gt;
     *
     * @protected
     * @return {draw2d.util.ArrayList}
     **/
    getFigures:function()
    {
      return this.figures;
    },

<span id='draw2d-Canvas-method-getLine'>    /**
</span>     * @method
     * Returns the line with the given id.
     *
     * @param {String} id The id of the line.
     * 
     * @type draw2d.shape.basic.Line
     **/
    getLine:function( id)
    {
      var count = this.lines.getSize();
      for(var i=0; i&lt;count;i++)
      {
         var line = this.lines.get(i);
         if(line.getId()===id){
            return line;
         }
      }
      return null;
    },

<span id='draw2d-Canvas-method-getFigure'>    /**
</span>     * @method
     * Returns the figure with the given id. 
     *
     * @param {String} id The id of the figure.
     * @return {draw2d.Figure}
     **/
    getFigure:function(/*:String*/ id)
    {
      var figure = null;
      this.figures.each(function(i,e){
          if(e.id===id){
              figure=e;
              return false;
           }
      });
      return figure;
    },

<span id='draw2d-Canvas-method-getIntersection'>    /**
</span>     * @method
     * Return all intersections draw2d.geo.Point between the given line and all other
     * lines in the canvas.
     * 
     * @param {draw2d.shape.basic.Line} line the line for the intersection test
     * @return {draw2d.util.ArrayList} 
     */
    getIntersection:function(line){
       var result = new draw2d.util.ArrayList();
       
       this.lineIntersections.each($.proxy(function(i, entry){
           if(entry.line ===line){
               entry.intersection.each(function(i,p){
                   result.add({x:p.x, y:p.y, justTouching:p.justTouching, other:entry.other});
               });
           }
       },this));
       
       return result;
    },
    



<span id='draw2d-Canvas-method-snapToHelper'>    /** 
</span>     * @method
     *  Adjust the coordinate with the installed SnapToHelper.
     *
     * @param  {draw2d.Figure} figure The related figure
     * @param  {draw2d.geo.Point} pos The position to adjust
     * 
     * @return {draw2d.geo.Point} the adjusted position
     * @private
     **/
    snapToHelper:function(figure,  pos)
    {
        this.editPolicy.each($.proxy(function(i,policy){
            pos = policy.snap(this, figure, pos);
        },this));

        return pos;
    },


<span id='draw2d-Canvas-method-registerPort'>    /**
</span>     * @method
     * Register a port to the canvas. This is required for other ports to find a valid drop target.
     * 
     * @param {draw2d.Port} port The new port which has been added to the Canvas.
     **/
    registerPort:function(port )
    {
      // All elements have the same drop targets.
      //
      port.targets= this.dropTargets;
      if(!this.commonPorts.contains(port)){
          this.commonPorts.add(port);
          this.dropTargets.add(port);
      }
    },

<span id='draw2d-Canvas-method-unregisterPort'>    /**
</span>     * @method
     * Remove a port from the internal cnavas registration. Now other ports can't find the
     * port anymore as drop target. The port itself is still visible.
     * 
     * @param {draw2d.Port} p The port to unregister as potential drop target
     * @private
     **/
    unregisterPort:function(port )
    {
        port.targets=null;

        this.commonPorts.remove(port);
        this.dropTargets.remove(port);
    },

<span id='draw2d-Canvas-method-getAllPorts'>    /**
</span>     * @method
     * Return all ports in the canvas
     * 
     */
    getAllPorts: function(){
        return this.commonPorts;
    },
    
<span id='draw2d-Canvas-method-getCommandStack'>    /**
</span>     * @method
     * Returns the command stack for the Canvas. Required for undo/redo support.
     *
     * @return {draw2d.command.CommandStack}
     **/
    getCommandStack:function()
    {
      return this.commandStack;
    },

<span id='draw2d-Canvas-method-getCurrentSelection'>    /**
</span>     * @method
     * Returns the current selected figure in the Canvas.
     *
     * @return {draw2d.Figure}
     * @deprecated
     **/
    getCurrentSelection:function()
    {
      return this.selection.getPrimary();
    },
    
<span id='draw2d-Canvas-method-getSelection'>    /**
</span>     * @method
     * Returns the current selection.
     *
     * @return {draw2d.Selection}
     **/
    getSelection:function()
    {
      return this.selection;
    },

<span id='draw2d-Canvas-method-setCurrentSelection'>    /**
</span>     * @method
     * Set the current selected figure in the workflow Canvas.
     *
     * @param {draw2d.Figure} figure The new selection.
     * @deprecated
     **/
    setCurrentSelection:function( figure )
    {
        this.selection.each($.proxy(function(i,e){
            this.editPolicy.each($.proxy(function(i,policy){
                if(typeof policy.unselect===&quot;function&quot;){
                    policy.unselect(this,e);
                }
            },this));
        },this));
 
        this.editPolicy.each($.proxy(function(i,policy){
            if(typeof policy.select===&quot;function&quot;){
                policy.select(this,figure);
            }
        },this));
    },

<span id='draw2d-Canvas-method-addSelectionListener'>    /**
</span>     * @method
     * Register a listener to the Canvas. The listener must provide a function &quot;onSelectionChanged&quot;.
     * 
     * @param {Object/Function} w an object which implements the 'onSelectionChanged' method or a callback function
     **/
    addSelectionListener:function(w)
    {
      if(w!==null)
      {
        if(typeof w ===&quot;function&quot;){
          this.selectionListeners.add({onSelectionChanged: w});
        } 
        else if(typeof w.onSelectionChanged===&quot;function&quot;){
          this.selectionListeners.add(w);
        }
        else{
          throw &quot;Object doesn't implement required callback method [onSelectionChanged]&quot;;
        }
      }
    },

<span id='draw2d-Canvas-method-removeSelectionListener'>    /**
</span>     * @method
     * unregister the listener from the canvas.
     * 
     * @param {Object/Function} w The object which will be removed from the selection eventing
     **/
    removeSelectionListener:function(/*:Object*/ w )
    {
      this.selectionListeners = this.selectionListeners.grep(function(listener){
          return listener !== w &amp;&amp; listener.onSelectionChanged!==w;
      });
    },


<span id='draw2d-Canvas-method-getBestFigure'>    /**
</span>     * @method
     * Returns the best figure at the location [x,y]. It is a simple hit test. Keep in mind that only visible objects 
     * are returned.
     *
     * @param {Number} x The x position.
     * @param {Number} y The y position.
     * @param {draw2d.Figure} [figureToIgnore] The figure which should be ignored.
     **/
    getBestFigure : function(x, y, figureToIgnore)
    {
        var result = null;
        var testFigure = null;
        var i=0;
        var children = null;
        
        // ResizeHandles first
        for ( i = 0, len = this.resizeHandles.getSize(); i &lt; len; i++)
        {
            testFigure = this.resizeHandles.get(i);
            if (testFigure.isVisible()===true &amp;&amp; testFigure.hitTest(x, y) === true &amp;&amp; testFigure !== figureToIgnore) 
            { 
                return testFigure; 
            }
        }

        // Checking ports
        for ( i = 0, len = this.commonPorts.getSize(); i &lt; len; i++) 
        {
            testFigure = this.commonPorts.get(i);
            if(testFigure !== figureToIgnore)
            {
                if (testFigure.isVisible()===true &amp;&amp; testFigure.hitTest(x, y) === true) 
                { 
                    return testFigure; 
                }
            }
        }

        // 2.) A line is the next option in the priority queue for a &quot;Best&quot; figure
        //
        result = this.getBestLine(x,y,figureToIgnore);
        if(result !==null){
            return result;
        }
        
        // 3.) Check now the common objects
        //     run from back to front to aware the z-oder of the figures
        for ( i = (this.figures.getSize()-1); i &gt;=0; i--)
        {
            var figure = this.figures.get(i);
            // check first a children of the figure
            //
            var checkRecursive = function(children){
                children.each(function(i,e){
                    checkRecursive(e.getChildren());
                    if(result===null&amp;&amp;e.isVisible()===true &amp;&amp; e.hitTest(x,y)===true){
                        result = e;
                    }
                    return result===null; // break the each-loop if we found an element
                });
            };
            checkRecursive( figure.getChildren());
            
            // ...and the figure itself
            //
            if (result ===null &amp;&amp; figure.isVisible()===true &amp;&amp; figure.hitTest(x, y) === true &amp;&amp; figure !== figureToIgnore)
            {
                if (result === null){
                    result = figure;
                }
                else if(result.getZOrder()&lt; figure.getZOrder())  {
                    result = figure;
                }
            }

            if(result !==null){
                return result;
            }
        }
        
        // 4.) Check the children of the lines as well
        //     Not selectable/draggable. But should receive onClick/onDoubleClick events 
        //      as well.
        var count = this.lines.getSize();
        for(i=0;i&lt; count;i++)
        {
          var line = this.lines.get(i);
          children= line.getChildren();
          children.each(function(i,e){
              if(e.isVisible()===true &amp;&amp; e.hitTest(x,y)===true){
                  result = e;
                  return false;
              }
              return true;
          });
        }
        
       return result;
    },


<span id='draw2d-Canvas-method-getBestLine'>    /**
</span>     * @method
     * Return the line which match the hands over coordinate
     *
     * @param {Number} x the x-coordinate for the hit test
     * @param {Number} y the x-coordinate for the hit test
     * @param {draw2d.shape.basic.Line} [lineToIgnore] a possible line which should be ignored for the hit test
     *
     * @private
     * @return {draw2d.shape.basic.Line}
     **/
    getBestLine:function( x,  y,  lineToIgnore)
    {
      var result = null;
      var count = this.lines.getSize();

      for(var i=0;i&lt; count;i++)
      {
        var line = this.lines.get(i);
        if(line.isVisible()===true &amp;&amp; line.hitTest(x,y)===true &amp;&amp; line!==lineToIgnore)
        {
            if(result===null){
               result = line;
               break;
            }
        }
      }
      return result;
    }, 


<span id='draw2d-Canvas-method-hideSnapToHelperLines'>    /**
</span>     * @private
     **/
    hideSnapToHelperLines:function()
    {
      this.hideSnapToHelperLineHorizontal();
      this.hideSnapToHelperLineVertical();
    },

<span id='draw2d-Canvas-method-hideSnapToHelperLineHorizontal'>    /**
</span>     * @private
     **/
    hideSnapToHelperLineHorizontal:function()
    {
    },

<span id='draw2d-Canvas-method-hideSnapToHelperLineVertical'>    /**
</span>     * @private
     **/
    hideSnapToHelperLineVertical:function()
    {

    },


<span id='draw2d-Canvas-method-onDragEnter'>    /**
</span>     * @method
     * Called by the framework during drag&amp;drop operations.&lt;br&gt;
     * Droppable can be setup with:
     * &lt;pre&gt;
     *     $(&quot;.draw2d_droppable&quot;).draggable({
     *          appendTo:&quot;#container&quot;,
     *          stack:&quot;#container&quot;,
     *          zIndex: 27000,
     *          helper:&quot;clone&quot;,
     *          start: function(e, ui){$(ui.helper).addClass(&quot;shadow&quot;);}
     *     });
     * &lt;/pre&gt;
     * Graphiti use the jQuery draggable/droppable lib. Please inspect
     * http://jqueryui.com/demos/droppable/ for further information.
     * 
     * @param {HTMLElement} draggedDomNode The DOM element which is currently dragging
     * 
    * @template
     **/
    onDragEnter : function( draggedDomNode )
    {
    },
 
    
<span id='draw2d-Canvas-method-onDrag'>    /**
</span>     * @method
     * Called if the DragDrop object is moving around.&lt;br&gt;
     * &lt;br&gt;
     * Graphiti use the jQuery draggable/droppable lib. Please inspect
     * http://jqueryui.com/demos/droppable/ for further information.
     * 
     * @param {HTMLElement} draggedDomNode The dragged DOM element.
     * @param {Number} x the x coordinate of the drag
     * @param {Number} y the y coordinate of the drag
     * 
     * @template
     **/
    onDrag:function(draggedDomNode, x, y )
    {
    },

        
<span id='draw2d-Canvas-method-onDragLeave'>    /**
</span>     * @method
     * Called if the DragDrop object leaving the current hover figure.&lt;br&gt;
     * &lt;br&gt;
     * Graphiti use the jQuery draggable/droppable lib. Please inspect
     * http://jqueryui.com/demos/droppable/ for further information.
     * 
     * @param {HTMLElement} draggedDomNode The figure which is currently dragging
     * 
     * @template
     **/
    onDragLeave:function( draggedDomNode )
    {
    },

    
<span id='draw2d-Canvas-method-onDrop'>    /**
</span>     * @method
     * Called if the user drop the droppedDomNode onto the canvas.&lt;br&gt;
     * &lt;br&gt;
     * Graphiti use the jQuery draggable/droppable lib. Please inspect
     * http://jqueryui.com/demos/droppable/ for further information.
     * 
     * @param {HTMLElement} droppedDomNode The dropped DOM element.
     * @param {Number} x the x coordinate of the drop
     * @param {Number} y the y coordinate of the drop
     * 
     * @template
     **/
    onDrop:function(droppedDomNode, x, y)
    {
    },
    
<span id='draw2d-Canvas-method-onKeyDown'>    /**
</span>     * @method
     * Callback if the user press a key
     * 
     * @param {Number} keyCode the pressed key
     * @param {Boolean} ctrl true if the CTRL key is pressed as well
     * @private
     **/
    onKeyDown:function(keyCode, ctrl)
    {
      // Figure loescht sich selbst, da dies den KeyDown Event empfangen
      // kann. Bei einer Linie geht dies leider nicht, und muss hier abgehandelt werden.
      //
      if(keyCode==46 &amp;&amp; this.selection.getPrimary()!==null){
         this.commandStack.execute(this.selection.getPrimary().createCommand(new draw2d.command.CommandType(draw2d.command.CommandType.DELETE)));
      }
      /*
      else if(keyCode==90 &amp;&amp; ctrl){
         this.commandStack.undo();
      }
      else if(keyCode==89 &amp;&amp; ctrl){
         this.commandStack.redo();
      }
      else if(keyCode ===107){
          this.setZoom(this.zoomFactor*0.95);
      }
      else if(keyCode ===109){
          this.setZoom(this.zoomFactor*1.05);
      }
      */
    },

<span id='draw2d-Canvas-method-onDoubleClick'>    /**
</span>     * @private
     **/
    onDoubleClick : function(/* :int */x, /* :int */y, shiftKey, ctrlKey)
    {
        // check if a line has been hit
        //
        var figure = this.getBestFigure(x, y);

        if(figure!==null){
            figure.onDoubleClick();
        }
        // forward the event to all install policies as well.
        // (since 4.0.0)
        this.editPolicy.each($.proxy(function(i,policy){
            policy.onDoubleClick(figure, x,y, shiftKey, ctrlKey);
        },this));
    },

<span id='draw2d-Canvas-method-onClick'>    /**
</span>     * @param {Number} x the x coordinate of the event
     * @param {Number} y the y coordinate of the event
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * @private
     **/
    onClick : function(x, y, shiftKey, ctrlKey)
    {
        // check if a figure has been hit
        //
        var figure = this.getBestFigure(x, y);
        
        // or a line/connection. May we should test the line before a figure..?
        // (since 4.0.0)
        if(figure===null){
            figure = this.getBestLine(x,y);
        }
        
        if(figure!==null){
            figure.onClick();
            
        }
        // forward the event to all install policies as well.
        // (since 3.0.0)
        this.editPolicy.each($.proxy(function(i,policy){
            policy.onClick(figure, x, y, shiftKey, ctrlKey);
        },this));

    },

<span id='draw2d-Canvas-method-onRightMouseDown'>    /**
</span>     * @method
     * The user has triggered a right click. Redirect them to a responsible figure. 
     * 
     * @param {Number} x The x-coordinate of the click
     * @param {Number} y The y-coordinate of the click
     * @param {Boolean} shiftKey true if the shift key has been pressed during this event
     * @param {Boolean} ctrlKey true if the ctrl key has been pressed during the event
     * 
     * @private
     * @since 1.1.0
     **/
    onRightMouseDown : function(x, y, shiftKey, ctrlKey)
    {
        var figure = this.getBestFigure(x, y);
        if(figure!==null){
            figure.onContextMenu(x,y);
            
            // forward the event to all installed policies of the figure
            // soft migration from onHookXYZ to Policies.
            // since 4.4.0
            figure.editPolicy.each($.proxy(function(i,policy){
                policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
            },this));
        }
        
        // forward the event to all install policies as well.
        // (since 4.4.0)
        this.editPolicy.each($.proxy(function(i,policy){
            policy.onRightMouseDown(figure, x, y, shiftKey, ctrlKey);
        },this));

    }
});</pre>
</body>
</html>
